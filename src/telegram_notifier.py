"""
Sistema de Notifica√ß√µes Telegram para Bot Pacifica
Implementa envio de notifica√ß√µes com robustez, fallbacks e persist√™ncia
"""

import os
import time
import logging
import requests
from typing import Dict, Any, Optional, List
import urllib3
from dotenv import load_dotenv
import json
from pathlib import Path

# Desabilitar warnings SSL
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)


class TelegramNotifier:
    """Sistema robusto de notifica√ß√µes Telegram com fallbacks e persist√™ncia"""
    
    def __init__(self):
        """Inicializa o sistema de notifica√ß√£o Telegram"""
        load_dotenv()
        
        self.logger = logging.getLogger(__name__)
        
        # Configura√ß√µes do ambiente
        self.enabled = os.getenv('TELEGRAM_ENABLED', 'false').lower() == 'true'
        self.bot_token = os.getenv('TELEGRAM_BOT_TOKEN', '').strip()
        self.chat_id = os.getenv('TELEGRAM_CHAT_ID', '').strip()
        
        # Valida√ß√£o b√°sica
        if self.enabled and (not self.bot_token or not self.chat_id):
            self.logger.error("‚ùå TELEGRAM_BOT_TOKEN ou TELEGRAM_CHAT_ID n√£o configurados")
            self.enabled = False
        
        # Configura√ß√µes de timeout e retry
        self.request_timeout = int(os.getenv('TELEGRAM_TIMEOUT_SECONDS', '45'))
        self.connect_timeout = int(os.getenv('TELEGRAM_CONNECT_TIMEOUT', '20'))
        self.max_retries = int(os.getenv('TELEGRAM_MAX_RETRIES', '5'))
        self.retry_delay = float(os.getenv('TELEGRAM_RETRY_DELAY_SECONDS', '3.0'))
        self.rate_limit = float(os.getenv('TELEGRAM_RATE_LIMIT_SECONDS', '2.0'))
        
        # URLs da API Telegram
        self.api_urls = [
            f"https://api.telegram.org/bot{self.bot_token}/sendMessage"
        ]
        
        # Rate limiting
        self.last_message_time = 0
        
        # Sistema de fila persistente
        self.queue_file = Path("data/telegram_queue.json")
        self.backup_file = Path("logs/telegram_backup.log")
        self.message_queue = []
        self.max_queue_size = 100
        
        # Configura√ß√µes de notifica√ß√£o espec√≠ficas
        self.notify_config = {
            'cycle_close': os.getenv('TELEGRAM_NOTIFY_CYCLE_CLOSE', 'true').lower() == 'true',
            'stop_loss': os.getenv('TELEGRAM_NOTIFY_STOP_LOSS', 'true').lower() == 'true',
            'take_profit': os.getenv('TELEGRAM_NOTIFY_TAKE_PROFIT', 'true').lower() == 'true',
            'session_limit': os.getenv('TELEGRAM_NOTIFY_SESSION_LIMIT', 'true').lower() == 'true',
            'pause_resume': os.getenv('TELEGRAM_NOTIFY_PAUSE_RESUME', 'true').lower() == 'true',
            'heartbeat': os.getenv('TELEGRAM_NOTIFY_HEARTBEAT', 'false').lower() == 'true'
        }
        
        # Carregar fila de mensagens salvas
        self._load_message_queue()
        
        if self.enabled:
            self.logger.info(f"‚úÖ Telegram Notifier ativado")
            self.logger.info(f"   Request timeout: {self.request_timeout}s")
            self.logger.info(f"   Connect timeout: {self.connect_timeout}s") 
            self.logger.info(f"   Max retries: {self.max_retries}")
            self.logger.info(f"   Chat ID: {self.chat_id}")
            if self.message_queue:
                self.logger.info(f"   üì¶ {len(self.message_queue)} mensagens pendentes na fila")
        else:
            self.logger.info("üîá Telegram Notifier desabilitado")

    def _ensure_directories(self):
        """Garante que os diret√≥rios necess√°rios existam"""
        self.queue_file.parent.mkdir(exist_ok=True)
        self.backup_file.parent.mkdir(exist_ok=True)

    def _load_message_queue(self):
        """Carrega fila de mensagens do arquivo"""
        try:
            if self.queue_file.exists():
                with open(self.queue_file, 'r', encoding='utf-8') as f:
                    self.message_queue = json.load(f)
                self.logger.debug(f"üì• {len(self.message_queue)} mensagens carregadas da fila")
        except Exception as e:
            self.logger.warning(f"‚ö†Ô∏è Erro ao carregar fila: {e}")
            self.message_queue = []

    def _save_message_queue(self):
        """Salva fila de mensagens no arquivo"""
        try:
            self._ensure_directories()
            with open(self.queue_file, 'w', encoding='utf-8') as f:
                json.dump(self.message_queue, f, ensure_ascii=False, indent=2)
        except Exception as e:
            self.logger.warning(f"‚ö†Ô∏è Erro ao salvar fila: {e}")

    def _add_to_queue(self, message: str, priority: str = "INFO", notification_type: str = "general"):
        """Adiciona mensagem na fila para envio posterior"""
        timestamp = time.time()
        queued_message = {
            "timestamp": timestamp,
            "message": message,
            "priority": priority,
            "type": notification_type,
            "attempts": 0,
            "max_attempts": 5
        }
        
        self.message_queue.append(queued_message)
        
        # Limitar tamanho da fila
        if len(self.message_queue) > self.max_queue_size:
            self.message_queue.pop(0)  # Remove mensagem mais antiga
        
        self._save_message_queue()
        self.logger.info(f"üì¶ Mensagem adicionada √† fila (total: {len(self.message_queue)})")

    def _send_http_request(self, message: str) -> bool:
        """Envia mensagem via HTTP com configura√ß√µes otimizadas"""
        
        for attempt in range(1, self.max_retries + 1):
            for url_index, api_url in enumerate(self.api_urls):
                try:
                    self.logger.debug(f"üì± Enviando via HTTP (tentativa {attempt}/{self.max_retries})")
                    
                    payload = {
                        'chat_id': self.chat_id,
                        'text': message,
                        'parse_mode': 'HTML',
                        'disable_web_page_preview': True
                    }
                    
                    # Configura√ß√µes de sess√£o otimizadas
                    session = requests.Session()
                    session.headers.update({
                        'Connection': 'close',
                        'User-Agent': 'BotPacifica/2.0',
                        'Accept': 'application/json',
                        'Content-Type': 'application/json'
                    })
                    
                    timeout = (self.connect_timeout, self.request_timeout)
                    
                    response = session.post(
                        api_url,
                        json=payload,
                        timeout=timeout,
                        verify=True,  # Usar verifica√ß√£o SSL padr√£o
                        allow_redirects=True
                    )
                    
                    session.close()
                    
                    if response.status_code == 200:
                        self.logger.debug("‚úÖ Mensagem Telegram enviada com sucesso")
                        return True
                    elif response.status_code == 429:
                        # Rate limiting do Telegram
                        retry_after = int(response.headers.get('Retry-After', 5))
                        self.logger.warning(f"üö´ Rate limit atingido. Aguardando {retry_after}s...")
                        time.sleep(retry_after)
                        continue
                    elif response.status_code == 400:
                        # Erro de request (chat_id inv√°lido, etc)
                        error_data = response.json() if response.headers.get('content-type', '').startswith('application/json') else response.text
                        self.logger.error(f"‚ùå Erro de configura√ß√£o Telegram: {error_data}")
                        return False  # N√£o tentar novamente
                    else:
                        self.logger.warning(f"‚ùå Erro HTTP {response.status_code}: {response.text[:200]}")
                        
                except requests.exceptions.ConnectTimeout as e:
                    self.logger.warning(f"‚è∞ Timeout de conex√£o (tentativa {attempt}): {str(e)}")
                except requests.exceptions.ReadTimeout as e:
                    self.logger.warning(f"‚è∞ Timeout de leitura (tentativa {attempt}): {str(e)}")
                except requests.exceptions.SSLError as e:
                    self.logger.warning(f"üîí Erro SSL (tentativa {attempt}): {str(e)}")
                except requests.exceptions.ConnectionError as e:
                    self.logger.warning(f"üåê Erro de conex√£o (tentativa {attempt}): {str(e)}")
                except Exception as e:
                    self.logger.warning(f"‚ùå Erro inesperado (tentativa {attempt}): {str(e)}")
            
            # Aguardar antes da pr√≥xima tentativa
            if attempt < self.max_retries:
                delay = self.retry_delay * attempt  # Backoff linear
                self.logger.debug(f"üîÑ Tentando novamente em {delay}s...")
                time.sleep(delay)
        
        return False

    def _backup_message(self, message: str, error: str = ""):
        """Salva mensagem em backup local"""
        try:
            self._ensure_directories()
            timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
            log_entry = f"[{timestamp}] TELEGRAM_BACKUP: {message}"
            if error:
                log_entry += f" | ERROR: {error}"
            
            with open(self.backup_file, "a", encoding="utf-8") as f:
                f.write(log_entry + "\n")
            self.logger.debug("üíæ Mensagem salva em backup local")
        except Exception as e:
            self.logger.error(f"‚ùå Erro ao salvar backup: {e}")

    def _format_message(self, title: str, message: str, priority: str = "INFO") -> str:
        """Formata mensagem com emoji e estrutura padr√£o"""
        emoji_map = {
            "INFO": "‚ÑπÔ∏è",
            "SUCCESS": "‚úÖ", 
            "WARNING": "‚ö†Ô∏è",
            "ERROR": "‚ùå",
            "CRITICAL": "üö®",
            "TRADE": "üíπ",
            "PROFIT": "üí∞",
            "LOSS": "üìâ"
        }
        
        emoji = emoji_map.get(priority.upper(), "üì¢")
        timestamp = time.strftime("%H:%M:%S")
        
        formatted_message = f"{emoji} <b>{title}</b> ({timestamp})\n{message}"
        
        # Limitar tamanho da mensagem (Telegram tem limite de 4096 caracteres)
        if len(formatted_message) > 4000:
            formatted_message = formatted_message[:3950] + "...\n<i>[Mensagem truncada]</i>"
        
        return formatted_message

    def _should_send_notification(self, notification_type: str) -> bool:
        """Verifica se deve enviar notifica√ß√£o baseado nas configura√ß√µes"""
        if not self.enabled:
            return False
        
        return self.notify_config.get(notification_type, True)

    def send_notification(self, title: str, message: str, priority: str = "INFO", 
                         notification_type: str = "general") -> bool:
        """Envia notifica√ß√£o formatada com fallbacks"""
        
        if not self._should_send_notification(notification_type):
            self.logger.debug(f"üîá Notifica√ß√£o '{notification_type}' desabilitada")
            return True
        
        if not self.enabled:
            self.logger.debug("üîá Telegram desabilitado - notifica√ß√£o ignorada")
            return True
        
        # Rate limiting
        current_time = time.time()
        time_since_last = current_time - self.last_message_time
        if time_since_last < self.rate_limit:
            time.sleep(self.rate_limit - time_since_last)
        
        # Formatar mensagem
        formatted_message = self._format_message(title, message, priority)
        
        # Tentar enviar
        success = self._send_http_request(formatted_message)
        
        if success:
            self.last_message_time = time.time()
        else:
            # Adicionar na fila e fazer backup
            self._add_to_queue(formatted_message, priority, notification_type)
            self._backup_message(formatted_message, "Failed to send")
        
        return success

    def send_trade_notification(self, action: str, symbol: str, price: float, 
                              quantity: float, pnl: float = None) -> bool:
        """Envia notifica√ß√£o de trade formatada"""
        
        action_emoji = {
            "BUY": "üü¢ COMPRA",
            "SELL": "üî¥ VENDA", 
            "CLOSE": "‚ö™ FECHAMENTO"
        }
        
        action_text = action_emoji.get(action.upper(), f"üìä {action}")
        
        message = f"{action_text} - {symbol}\n"
        message += f"üí∞ Pre√ßo: <code>${price:.4f}</code>\n"
        message += f"üìä Quantidade: <code>{quantity}</code>"
        
        if pnl is not None:
            pnl_emoji = "üìà" if pnl >= 0 else "üìâ"
            pnl_color = "+" if pnl >= 0 else ""
            message += f"\n{pnl_emoji} PnL: <code>{pnl_color}${pnl:.2f}</code>"
        
        priority = "SUCCESS" if pnl is None or pnl >= 0 else "WARNING"
        return self.send_notification("Trade Executado", message, priority, "trade")

    def send_cycle_notification(self, cycle_data: Dict[str, Any]) -> bool:
        """Envia notifica√ß√£o de fechamento de ciclo"""
        
        profit = cycle_data.get('profit', 0)
        trades = cycle_data.get('trades', 0)
        duration = cycle_data.get('duration', 0)
        
        emoji = "üéØ" if profit >= 0 else "üìâ"
        message = f"Ciclo de Grid Finalizado\n"
        message += f"üíπ Trades: <code>{trades}</code>\n"
        message += f"‚è±Ô∏è Dura√ß√£o: <code>{duration}min</code>\n"
        message += f"üí∞ Resultado: <code>${profit:.2f}</code>"
        
        priority = "SUCCESS" if profit >= 0 else "WARNING"
        return self.send_notification("Ciclo Completo", message, priority, "cycle_close")

    def send_risk_alert(self, alert_type: str, details: Dict[str, Any]) -> bool:
        """Envia alerta de gerenciamento de risco"""
        
        risk_emoji = {
            "STOP_LOSS": "üõë",
            "TAKE_PROFIT": "üéØ",
            "MAX_LOSS": "‚ö†Ô∏è",
            "POSITION_LIMIT": "üìä",
            "MARGIN_CALL": "üö®"
        }
        
        emoji = risk_emoji.get(alert_type, "‚ö†Ô∏è")
        
        message = f"{emoji} <b>Alerta de Risco</b>\n"
        message += f"üîî Tipo: <code>{alert_type}</code>\n"
        
        for key, value in details.items():
            if isinstance(value, float):
                message += f"‚Ä¢ {key}: <code>{value:.4f}</code>\n"
            else:
                message += f"‚Ä¢ {key}: <code>{value}</code>\n"
        
        notification_type = alert_type.lower()
        return self.send_notification("Risk Manager", message, "WARNING", notification_type)

    def send_status_update(self, status: str, details: Dict[str, Any] = None) -> bool:
        """Envia atualiza√ß√£o de status do bot"""
        
        status_emoji = {
            "STARTED": "üöÄ",
            "STOPPED": "üõë",
            "PAUSED": "‚è∏Ô∏è",
            "RESUMED": "‚ñ∂Ô∏è",
            "ERROR": "‚ùå",
            "HEALTHY": "üíö"
        }
        
        emoji = status_emoji.get(status.upper(), "üìä")
        message = f"Status do Bot: <b>{status}</b>"
        
        if details:
            message += "\n"
            for key, value in details.items():
                message += f"\n‚Ä¢ {key}: <code>{value}</code>"
        
        priority = "ERROR" if status.upper() == "ERROR" else "INFO"
        return self.send_notification("Bot Status", message, priority, "pause_resume")

    def send_heartbeat(self, stats: Dict[str, Any] = None) -> bool:
        """Envia heartbeat peri√≥dico"""
        
        if not self._should_send_notification("heartbeat"):
            return True
        
        message = "Bot ativo e operando"
        
        if stats:
            message += "\n"
            for key, value in stats.items():
                if isinstance(value, float):
                    message += f"\n‚Ä¢ {key}: <code>{value:.2f}</code>"
                else:
                    message += f"\n‚Ä¢ {key}: <code>{value}</code>"
        
        return self.send_notification("Heartbeat", message, "INFO", "heartbeat")

    def test_connection(self) -> bool:
        """Testa a conex√£o com o Telegram"""
        
        if not self.enabled:
            self.logger.info("üîá Telegram desabilitado - teste ignorado")
            return True
        
        test_message = "üß™ Teste de conex√£o Telegram - Bot Pacifica ativo!"
        return self.send_notification("Teste de Conex√£o", test_message, "INFO")

    def process_message_queue(self) -> int:
        """Processa mensagens na fila para reenvio"""
        
        if not self.message_queue:
            return 0
        
        sent_count = 0
        remaining_messages = []
        
        for queued_msg in self.message_queue:
            queued_msg["attempts"] += 1
            
            # Tentar enviar mensagem da fila
            success = self._send_http_request(queued_msg["message"])
            
            if success:
                sent_count += 1
                self.logger.info(f"‚úÖ Mensagem da fila enviada (tentativa {queued_msg['attempts']})")
            elif queued_msg["attempts"] < queued_msg.get("max_attempts", 5):
                remaining_messages.append(queued_msg)
            else:
                self.logger.warning(f"‚ùå Mensagem descartada ap√≥s {queued_msg['attempts']} tentativas")
                self._backup_message(queued_msg["message"], "Max attempts reached")
        
        self.message_queue = remaining_messages
        self._save_message_queue()
        
        if sent_count > 0:
            self.logger.info(f"üì§ {sent_count} mensagens da fila enviadas com sucesso")
        
        return sent_count

    def get_queue_stats(self) -> Dict[str, int]:
        """Retorna estat√≠sticas da fila de mensagens"""
        stats = {
            "total_messages": len(self.message_queue),
            "high_priority": 0,
            "medium_priority": 0,
            "low_priority": 0
        }
        
        for msg in self.message_queue:
            priority = msg.get("priority", "INFO").upper()
            if priority in ["CRITICAL", "ERROR"]:
                stats["high_priority"] += 1
            elif priority in ["WARNING"]:
                stats["medium_priority"] += 1
            else:
                stats["low_priority"] += 1
        
        return stats

    def clear_queue(self) -> int:
        """Limpa a fila de mensagens"""
        count = len(self.message_queue)
        self.message_queue = []
        self._save_message_queue()
        self.logger.info(f"üóëÔ∏è {count} mensagens removidas da fila")
        return count


# Fun√ß√£o de conveni√™ncia para compatibilidade
def create_telegram_notifier() -> TelegramNotifier:
    """Cria inst√¢ncia do notificador Telegram"""
    return TelegramNotifier()


if __name__ == "__main__":
    # Teste r√°pido
    logging.basicConfig(
        level=logging.DEBUG,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    notifier = TelegramNotifier()
    
    if notifier.enabled:
        print("üß™ Testando Telegram Notifier...")
        
        # Teste de conex√£o
        success = notifier.test_connection()
        print(f"‚úÖ Teste de conex√£o: {'‚úì' if success else '‚úó'}")
        
        # Teste de notifica√ß√£o de trade
        success = notifier.send_trade_notification("BUY", "SOL", 150.25, 10.0, 15.50)
        print(f"‚úÖ Teste de trade: {'‚úì' if success else '‚úó'}")
        
        # Estat√≠sticas da fila
        stats = notifier.get_queue_stats()
        print(f"üìä Fila: {stats['total_messages']} mensagens")
        
        # Processar fila se houver mensagens pendentes
        if stats['total_messages'] > 0:
            sent = notifier.process_message_queue()
            print(f"üì§ {sent} mensagens da fila processadas")
    else:
        print("üîá Telegram desabilitado")